<?xml version="1.0" encoding="UTF-8" standalone="yes"?>
<dict>
    <entry key="add_primary_key_to_header">
        <int>1</int>
    </entry>
    <entry key="blockstrategy">
        <dict>
            <entry key="mininterblockinterval">
                <int>1000</int>
            </entry>
            <entry key="name">
                <string>net.postchain.base.BaseBlockBuildingStrategy</string>
            </entry>
        </dict>
    </entry>
    <entry key="config_consensus_strategy">
        <string>HEADER_HASH</string>
    </entry>
    <entry key="configurationfactory">
        <string>net.postchain.gtx.GTXBlockchainConfigurationFactory</string>
    </entry>
    <entry key="gtx">
        <dict>
            <entry key="modules">
                <array>
                    <string>net.postchain.rell.module.RellPostchainModuleFactory</string>
                    <string>net.postchain.gtx.StandardOpsGTXModule</string>
                    <string>net.postchain.rell.module.RellPostchainModuleFactory</string>
                    <string>net.postchain.gtx.StandardOpsGTXModule</string>
                    <string>net.postchain.gtx.extensions.vectordb.VectorDbGTXModule</string>
                </array>
            </entry>
            <entry key="rell">
                <dict>
                    <entry key="compilerVersion">
                        <string>0.14.8</string>
                    </entry>
                    <entry key="modules">
                        <array>
                            <string>vector_example</string>
                        </array>
                    </entry>
                    <entry key="sources">
                        <dict>
                            <entry key="lib/module.rell">
                                <string>module;

/**
 * Stores a vector in the database.
 *
 * @param context The context of the vector.
 * @param vector The vector to store.
 * @param id The id of the vector, this is the id to be returned from a search.
 */
function store_vector(context: integer, vector: text, id: integer, metadata: json) {
    op_context.emit_event("store_vector", (context = context, vector = vector, id = id, metadata = metadata).to_gtv_pretty());
}

/**
 * Struct used to store vectors and id when sent to store_vectors as list.
 */
struct vector_db_data {
    vector: text;
    id: integer;
    metadata: json;
}

/**
 * Store a list of vectors in the database.
 *
 * @param context The context of the vector.
 * @param vectors List of vectors to store.
 */
function store_vectors(context: integer, vectors: list&lt;vector_db_data&gt;) {
    op_context.emit_event("store_vectors", (context = context, vectors = vectors).to_gtv_pretty());
}


/**
 * Delete one vector from database.
 */
function delete_vector(context: integer, id: integer) {
    op_context.emit_event("delete_vector", (context = context, id = id).to_gtv_pretty());
}

/**
 * Delete a set of vectors from the database.
 */
function delete_vectors(context: integer, ids: set&lt;integer&gt;) {
    op_context.emit_event("delete_vectors", (context = context, ids = ids).to_gtv_pretty());
}

/** A vector search result object. The query template function gets a list of this object. */
struct object_distance {
    id: integer;
    distance: decimal;
}</string>
                            </entry>
                            <entry key="vector_example/module.rell">
                                <string>module;

import lib.*;

entity message { 
    id: integer;
    text: text;
    metadata: json;
}

val CONTEXT_MESSAGE = 0;

/**
 * Add a message with a vector. The vector is emitted to the extension and stored in the database with the entity
 * rowid as id.
 *
 * @param text The text message represented by this vector
 * @param vector The vector on format [1.0,2.0,...]
 */
operation add_message(id: integer, text: text, metadata: json, vector: text) {
    val message_entity = create message (id, text, metadata);
    store_vector(CONTEXT_MESSAGE, vector, id, metadata);
}

struct message_data {
    id: integer;
    text: text;
    metadata: json;
    vector: text;
}

operation add_messages(messages: list&lt;message_data&gt;) {
    val vector_ids = list&lt;vector_db_data&gt;();
    for (message in messages) {
        val message_entity = create message (message.id, message.text, message.metadata);
        vector_ids.add(vector_db_data(message.vector, message.id, message_entity.metadata));
    }
    store_vectors(CONTEXT_MESSAGE, vector_ids);
}

/** Delete text and its vector */
operation delete_message(id: integer) {
    val msg = message @ { id };
    delete_vector(CONTEXT_MESSAGE, msg.rowid.to_integer());
    delete msg;
}

operation delete_messages(ids: list&lt;integer&gt;) {
    val message_entities = message @* { .id in ids };
    delete_vectors(CONTEXT_MESSAGE, message_entities @ {} (@set .rowid.to_integer()));
    delete message_entities;
}

/**
 * Query template function to map vector ids to corresponding texts
 *
 * @param closest_results The vector search result supplied by the `query_closest_objects` search.
 */
query get_messages(closest_results: list&lt;object_distance&gt;): list&lt;text&gt; {
    val closest_result_ids = closest_results @ {} ( @set(rowid(.id)) );
    val messages_map = message @ { .rowid in closest_result_ids } ( @map(.rowid.to_integer(), .text) );
    val results = list&lt;text&gt;();
    for (closest_result in closest_results) {
        results.add(messages_map[closest_result.id]);
    }
    return results;
}

/** Struct returned by get_messages_with_distance */
struct message_distance {
    id: integer;
    text: text;
    distance: decimal;
    metadata: json;
}

/**
 * Query template function to map vector ids to corresponding texts with distance
 *
 * @param closest_results The vector search result supplied by the `query_closest_objects` search.
 */
query get_messages_with_distance(closest_results: list&lt;object_distance&gt;): list&lt;message_distance&gt; {
    val closest_results_map = closest_results @ {} ( @set(rowid(.id)) );
    val ids_map = message @ { .rowid in closest_results_map } ( @map(.rowid.to_integer(), .id) );
    val messages_map = message @ { .rowid in closest_results_map } ( @map(.rowid.to_integer(), .text) );
    val metadatas_map = message @ { .rowid in closest_results_map } ( @map(.rowid.to_integer(), .metadata) );

    val results = list&lt;message_distance&gt;();
    for (closest_result in closest_results) {
        results.add(message_distance(ids_map[closest_result.id], messages_map[closest_result.id], closest_result.distance, metadatas_map[closest_result.id]));
    }
    return results;
}

/**
 * Query template function with custom arguments
 *
 * @param closest_results The vector search result supplied by the `query_closest_objects` search.
 */
query get_messages_with_filter(closest_results: list&lt;object_distance&gt;, text_filter: text): list&lt;text&gt; {
    val closest_result_ids = closest_results @ {} ( @set(rowid(.id)) );
    val messages_map = message @ { .rowid in closest_result_ids } ( @map(.rowid.to_integer(), .text) );
    val results = list&lt;text&gt;();
    for (closest_result in closest_results) {
        val message = messages_map[closest_result.id];
        if (message.contains(text_filter)) {
            results.add(messages_map[closest_result.id]);
        }
    }
    return results;
}
</string>
                            </entry>
                        </dict>
                    </entry>
                    <entry key="strictGtvConversion">
                        <int>1</int>
                    </entry>
                    <entry key="version">
                        <string>0.14.5</string>
                    </entry>
                </dict>
            </entry>
        </dict>
    </entry>
    <entry key="revolt">
        <dict>
            <entry key="fast_revolt_status_timeout">
                <int>2000</int>
            </entry>
            <entry key="revolt_when_should_build_block">
                <int>1</int>
            </entry>
        </dict>
    </entry>
    <entry key="vector_db_extension">
        <dict>
            <entry key="dimensions">
                <int>1536</int>
            </entry>
            <entry key="max_vectors">
                <int>100</int>
            </entry>
        </dict>
    </entry>
</dict>
