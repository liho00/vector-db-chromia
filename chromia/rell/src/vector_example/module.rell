module;

import lib.*;

entity message { 
    id: integer;
    text: text;
    metadata: json;
}

val CONTEXT_MESSAGE = 0;

/**
 * Add a message with a vector. The vector is emitted to the extension and stored in the database with the entity
 * rowid as id.
 *
 * @param text The text message represented by this vector
 * @param vector The vector on format [1.0,2.0,...]
 */
operation add_message(id: integer, text: text, metadata: json, vector: text) {
    val message_entity = create message (id, text, metadata);
    store_vector(CONTEXT_MESSAGE, vector, id, metadata);
}

struct message_data {
    id: integer;
    text: text;
    metadata: json;
    vector: text;
}

operation add_messages(messages: list<message_data>) {
    val vector_ids = list<vector_db_data>();
    for (message in messages) {
        val message_entity = create message (message.id, message.text, message.metadata);
        vector_ids.add(vector_db_data(message.vector, message.id, message_entity.metadata));
    }
    store_vectors(CONTEXT_MESSAGE, vector_ids);
}

/** Delete text and its vector */
operation delete_message(id: integer) {
    val msg = message @ { id };
    delete_vector(CONTEXT_MESSAGE, msg.rowid.to_integer());
    delete msg;
}

operation delete_messages(ids: list<integer>) {
    val message_entities = message @* { .id in ids };
    delete_vectors(CONTEXT_MESSAGE, message_entities @ {} (@set .rowid.to_integer()));
    delete message_entities;
}

/**
 * Query template function to map vector ids to corresponding texts
 *
 * @param closest_results The vector search result supplied by the `query_closest_objects` search.
 */
query get_messages(closest_results: list<object_distance>): list<text> {
    val closest_result_ids = closest_results @ {} ( @set(rowid(.id)) );
    val messages_map = message @ { .rowid in closest_result_ids } ( @map(.rowid.to_integer(), .text) );
    val results = list<text>();
    for (closest_result in closest_results) {
        results.add(messages_map[closest_result.id]);
    }
    return results;
}

/** Struct returned by get_messages_with_distance */
struct message_distance {
    id: integer;
    text: text;
    distance: decimal;
    metadata: json;
}

/**
 * Query template function to map vector ids to corresponding texts with distance
 *
 * @param closest_results The vector search result supplied by the `query_closest_objects` search.
 */
query get_messages_with_distance(closest_results: list<object_distance>): list<message_distance> {
    val closest_results_map = closest_results @ {} ( @set(rowid(.id)) );
    val ids_map = message @ { .rowid in closest_results_map } ( @map(.rowid.to_integer(), .id) );
    val messages_map = message @ { .rowid in closest_results_map } ( @map(.rowid.to_integer(), .text) );
    val metadatas_map = message @ { .rowid in closest_results_map } ( @map(.rowid.to_integer(), .metadata) );

    val results = list<message_distance>();
    for (closest_result in closest_results) {
        results.add(message_distance(ids_map[closest_result.id], messages_map[closest_result.id], closest_result.distance, metadatas_map[closest_result.id]));
    }
    return results;
}

/**
 * Query template function with custom arguments
 *
 * @param closest_results The vector search result supplied by the `query_closest_objects` search.
 */
query get_messages_with_filter(closest_results: list<object_distance>, text_filter: text): list<text> {
    val closest_result_ids = closest_results @ {} ( @set(rowid(.id)) );
    val messages_map = message @ { .rowid in closest_result_ids } ( @map(.rowid.to_integer(), .text) );
    val results = list<text>();
    for (closest_result in closest_results) {
        val message = messages_map[closest_result.id];
        if (message.contains(text_filter)) {
            results.add(messages_map[closest_result.id]);
        }
    }
    return results;
}
